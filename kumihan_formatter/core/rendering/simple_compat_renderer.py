"""Simple互換レンダリング専用モジュール

MainRenderer から SimpleHTMLRenderer 互換の処理を分離。
既存の公開API（MainRenderer.render_simple_parsed_data）は保持し、
本クラスに委譲することで責務分割と可読性を高める。
"""

from __future__ import annotations

from typing import Any, Dict, List

from ...core.utilities.logger import get_logger


class SimpleCompatRenderer:
    """SimpleHTMLRenderer 互換の最小レンダラー。

    - 辞書形式の解析結果（parsed_data）を受け取り、HTML文字列を返す。
    - MainRenderer と同等の出力を維持する（ふるまい不変）。
    """

    def __init__(self) -> None:
        self.logger = get_logger(__name__)

    # ---- Public API -----------------------------------------------------
    def render_simple_parsed_data(self, parsed_data: Dict[str, Any]) -> str:
        """SimpleHTMLRendererとの互換出力を生成する。

        Args:
            parsed_data: 解析結果辞書（tests/unit/test_simple_renderer.py 依存）

        Returns:
            HTML文字列
        """
        try:
            if parsed_data.get("status") != "success":
                return self._render_error_page(
                    parsed_data.get("error", "Unknown error")
                )

            elements = parsed_data.get("elements", [])
            if not elements:
                return self._render_empty_page()

            html_body = self._render_simple_elements(elements)
            return self._wrap_in_simple_html_document(html_body)

        except Exception as e:  # pragma: no cover - 保護的フォールバック
            self.logger.error(f"Simple render error: {e}")
            return self._render_error_page(str(e))

    # ---- Internal helpers (compatible behavior) ------------------------
    def _render_simple_elements(self, elements: List[Dict[str, Any]]) -> str:
        html_parts: List[str] = []

        for element in elements:
            element_type = element.get("type", "")
            content = element.get("content", "")
            attributes = element.get("attributes", {})

            if element_type == "kumihan_block":
                html_parts.append(
                    self._render_simple_kumihan_block(content, attributes)
                )
            elif element_type.startswith("heading_"):
                level_str = element_type.split("_")[1]
                try:
                    level = int(level_str)
                except ValueError:
                    level = 1
                html_parts.append(self._render_simple_heading(content, level))
            elif element_type == "paragraph":
                html_parts.append(self._render_simple_paragraph(content))
            elif element_type == "list_item":
                list_type = attributes.get("list_type", "unordered")
                html_parts.append(self._render_simple_list_item(content, list_type))
            else:
                html_parts.append(self._render_simple_paragraph(content))

        return "\n".join(html_parts)

    def _render_simple_kumihan_block(
        self, content: str, attributes: Dict[str, str]
    ) -> str:
        decoration = attributes.get("decoration", "")
        css_class = self._get_simple_decoration_class(decoration)

        return f"""<div class="kumihan-block {css_class}">
    <div class="decoration">{self._escape_html(decoration)}</div>
    <div class="content">{self._escape_html(content)}</div>
</div>"""

    def _render_simple_heading(self, content: str, level: int) -> str:
        level = max(1, min(6, level))
        return (
            f'<h{level} class="heading-{level}">{self._escape_html(content)}</h{level}>'
        )

    def _render_simple_paragraph(self, content: str) -> str:
        return f'<p class="paragraph">{content}</p>'

    def _render_simple_list_item(self, content: str, list_type: str) -> str:
        tag = "ul" if list_type == "unordered" else "ol"
        return f'<{tag} class="list-{list_type}"><li>{self._escape_html(content)}</li></{tag}>'

    def _get_simple_decoration_class(self, decoration: str) -> str:
        decoration_map = {
            "重要": "important",
            "注意": "warning",
            "情報": "info",
            "引用": "quote",
            "コード": "code",
            "例": "example",
        }
        return decoration_map.get(decoration, "default")

    def _wrap_in_simple_html_document(self, body_content: str) -> str:
        from datetime import datetime

        return f"""<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kumihan-Formatter 出力</title>
    <style>
{self._get_simple_default_styles()}
    </style>
    </head>
<body>
    <div class="container">
        <header class="header">
            <h1>Kumihan-Formatter</h1>
            <p>Generated at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </header>
        <main class="content">
{body_content}
        </main>
        <footer class="footer">
            <p>Generated by Kumihan-Formatter v4.0.0-minimal</p>
        </footer>
    </div>
</body>
</html>"""

    def _render_error_page(self, error_message: str) -> str:
        return f"""<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Kumihan-Formatter - エラー</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .error {{ background: #fee; border: 1px solid #faa; padding: 20px; border-radius: 5px; }}
        .error h1 {{ color: #c33; }}
    </style>
</head>
<body>
    <div class="error">
        <h1>エラーが発生しました</h1>
        <p>{self._escape_html(error_message)}</p>
    </div>
</body>
</html>"""

    def _render_empty_page(self) -> str:
        return """<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Kumihan-Formatter - 空の文書</title>
</head>
<body>
    <h1>空の文書</h1>
    <p>解析する内容がありません。</p>
</body>
</html>"""

    def _get_simple_default_styles(self) -> str:
        return """        body {
            font-family: 'Hiragino Kaku Gothic ProN', 'ヒラギノ角ゴ ProN W3', Meiryo, メイリオ, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        .header {
            background: #4a90e2;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
        }
        
        .content {
            padding: 30px;
        }
        
        .kumihan-block {
            margin: 20px 0;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .kumihan-block.important {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }
        
        .kumihan-block.warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        
        .kumihan-block.info {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .kumihan-block.default {
            background: #e9ecef;
            border-left: 4px solid #6c757d;
        }
        
        .decoration {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
        }
        
        .content {
            color: #212529;
        }
        
        .paragraph {
            margin: 15px 0;
        }
        
        .list-unordered, .list-ordered {
            margin: 15px 0;
        }
        
        .footer {
            background: #6c757d;
            color: white;
            text-align: center;
            padding: 15px;
            font-size: 0.9em;
        }"""

    # Local escape (MainRendererの _escape_html と同等の挙動)
    def _escape_html(self, text: str) -> str:
        if not text:
            return ""
        return (
            text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&#39;")
        )


__all__ = ["SimpleCompatRenderer"]
