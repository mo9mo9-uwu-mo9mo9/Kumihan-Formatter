"""
Áµ±‰∏Ä„Ç®„É©„Éº„É¨„Éù„Éº„ÉàÊ©üËÉΩ

Issue #240ÂØæÂøú: „Ç®„É©„Éº„ÅÆË©≥Á¥∞„É¨„Éù„Éº„Éà„Éª‰øÆÊ≠£ÊèêÊ°à„ÉªË§áÊï∞„Ç®„É©„Éº‰∏ÄÊã¨Ë°®Á§∫
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Dict, Any
from pathlib import Path
import json
from datetime import datetime


class ErrorSeverity(Enum):
    """„Ç®„É©„Éº„ÅÆÈáçË¶ÅÂ∫¶"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class ErrorCategory(Enum):
    """„Ç®„É©„Éº„ÅÆ„Ç´„ÉÜ„Ç¥„É™"""
    SYNTAX = "syntax"           # Ë®òÊ≥ï„Ç®„É©„Éº
    STRUCTURE = "structure"     # ÊßãÈÄ†„Ç®„É©„Éº
    KEYWORD = "keyword"         # „Ç≠„Éº„ÉØ„Éº„Éâ„Ç®„É©„Éº
    ATTRIBUTE = "attribute"     # Â±ûÊÄß„Ç®„É©„Éº
    FILE = "file"              # „Éï„Ç°„Ç§„É´„Ç®„É©„Éº
    COMPATIBILITY = "compatibility"  # ‰∫íÊèõÊÄß„Ç®„É©„Éº


@dataclass
class ErrorLocation:
    """„Ç®„É©„Éº‰ΩçÁΩÆÊÉÖÂ†±"""
    line: int
    column: Optional[int] = None
    context_start: Optional[int] = None
    context_end: Optional[int] = None
    
    def __str__(self) -> str:
        if self.column is not None:
            return f"Ë°å{self.line}:{self.column}"
        return f"Ë°å{self.line}"


@dataclass
class FixSuggestion:
    """‰øÆÊ≠£ÊèêÊ°à"""
    description: str                    # ‰øÆÊ≠£ÂÜÖÂÆπ„ÅÆË™¨Êòé
    original_text: Optional[str] = None # ÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà
    suggested_text: Optional[str] = None # ÊèêÊ°à„ÉÜ„Ç≠„Çπ„Éà
    action_type: str = "replace"        # "replace", "insert", "delete"
    confidence: float = 1.0             # ÊèêÊ°à„ÅÆ‰ø°È†ºÂ∫¶ (0.0-1.0)
    
    def __str__(self) -> str:
        if self.original_text and self.suggested_text:
            return f"{self.description}\n  Â§âÊõ¥Ââç: {self.original_text}\n  Â§âÊõ¥Âæå: {self.suggested_text}"
        return self.description


@dataclass
class DetailedError:
    """Ë©≥Á¥∞„Ç®„É©„ÉºÊÉÖÂ†±"""
    # Âü∫Êú¨ÊÉÖÂ†±
    error_id: str                           # ‰∏ÄÊÑè„Å™„Ç®„É©„ÉºID
    severity: ErrorSeverity                 # ÈáçË¶ÅÂ∫¶
    category: ErrorCategory                 # „Ç´„ÉÜ„Ç¥„É™
    title: str                              # „Ç®„É©„Éº„Çø„Ç§„Éà„É´
    message: str                            # Ë©≥Á¥∞„É°„ÉÉ„Çª„Éº„Ç∏
    
    # ‰ΩçÁΩÆÊÉÖÂ†±
    file_path: Optional[Path] = None        # „Éï„Ç°„Ç§„É´„Éë„Çπ
    location: Optional[ErrorLocation] = None # „Ç®„É©„Éº‰ΩçÁΩÆ
    
    # „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
    context_lines: List[str] = field(default_factory=list)  # Âë®Ëæ∫Ë°å
    highlighted_line: Optional[str] = None   # „Éè„Ç§„É©„Ç§„Éà„Åï„Çå„ÅüÂïèÈ°åË°å
    
    # ‰øÆÊ≠£ÊîØÊè¥
    fix_suggestions: List[FixSuggestion] = field(default_factory=list)
    help_url: Optional[str] = None          # „Éò„É´„ÉóURL
    learn_more: Optional[str] = None        # Â≠¶Áøí„É™„É≥„ÇØ
    
    # „É°„Çø„Éá„Éº„Çø
    timestamp: datetime = field(default_factory=datetime.now)
    additional_info: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        """‰∫∫Èñì„ÅåË™≠„Åø„ÇÑ„Åô„ÅÑÂΩ¢Âºè„Åß„Ç®„É©„Éº„ÇíË°®Á§∫"""
        lines = [
            f"[{self.severity.value.upper()}] {self.title}",
            f"  {self.message}"
        ]
        
        if self.file_path and self.location:
            lines.append(f"  Â†¥ÊâÄ: {self.file_path.name} {self.location}")
        
        if self.highlighted_line:
            lines.extend([
                "  ÂïèÈ°åË°å:",
                f"    {self.highlighted_line}"
            ])
        
        if self.fix_suggestions:
            lines.append("  ‰øÆÊ≠£ÊèêÊ°à:")
            for i, suggestion in enumerate(self.fix_suggestions, 1):
                lines.append(f"    {i}. {suggestion}")
        
        return "\n".join(lines)


class ErrorReport:
    """„Ç®„É©„Éº„É¨„Éù„Éº„ÉàÁµ±Âêà„ÇØ„É©„Çπ"""
    
    def __init__(self, source_file: Optional[Path] = None):
        self.source_file = source_file
        self.errors: List[DetailedError] = []
        self.warnings: List[DetailedError] = []
        self.info: List[DetailedError] = []
        self.generation_time = datetime.now()
    
    def add_error(self, error: DetailedError) -> None:
        """„Ç®„É©„Éº„ÇíËøΩÂä†"""
        if error.severity == ErrorSeverity.ERROR or error.severity == ErrorSeverity.CRITICAL:
            self.errors.append(error)
        elif error.severity == ErrorSeverity.WARNING:
            self.warnings.append(error)
        else:
            self.info.append(error)
    
    def has_errors(self) -> bool:
        """„Ç®„É©„Éº„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        return len(self.errors) > 0
    
    def has_warnings(self) -> bool:
        """Ë≠¶Âëä„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        return len(self.warnings) > 0
    
    def get_total_count(self) -> int:
        """Á∑èÂïèÈ°åÊï∞„ÇíÂèñÂæó"""
        return len(self.errors) + len(self.warnings) + len(self.info)
    
    def get_summary(self) -> str:
        """„Çµ„Éû„É™„ÉºÊÉÖÂ†±„ÇíÂèñÂæó"""
        error_count = len(self.errors)
        warning_count = len(self.warnings)
        info_count = len(self.info)
        
        parts = []
        if error_count > 0:
            parts.append(f"{error_count}ÂÄã„ÅÆ„Ç®„É©„Éº")
        if warning_count > 0:
            parts.append(f"{warning_count}ÂÄã„ÅÆË≠¶Âëä")
        if info_count > 0:
            parts.append(f"{info_count}ÂÄã„ÅÆÊÉÖÂ†±")
        
        if not parts:
            return "ÂïèÈ°å„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü"
        
        return "„ÄÅ".join(parts) + "„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü"
    
    def to_console_output(self, show_info: bool = False) -> str:
        """„Ç≥„É≥„ÇΩ„Éº„É´Ë°®Á§∫Áî®„ÅÆÊñáÂ≠óÂàó„ÇíÁîüÊàê"""
        lines = []
        
        # „Éò„ÉÉ„ÉÄ„Éº
        if self.source_file:
            lines.append(f"=== {self.source_file.name} „ÅÆ„Ç®„É©„Éº„É¨„Éù„Éº„Éà ===")
        else:
            lines.append("=== „Ç®„É©„Éº„É¨„Éù„Éº„Éà ===")
        
        lines.append(f"ÂÆüË°åÊôÇÂàª: {self.generation_time.strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"ÁµêÊûú: {self.get_summary()}")
        lines.append("")
        
        # „Ç®„É©„ÉºË°®Á§∫
        if self.errors:
            lines.append("üö´ „Ç®„É©„Éº:")
            for error in self.errors:
                lines.append(str(error))
                lines.append("")
        
        # Ë≠¶ÂëäË°®Á§∫
        if self.warnings:
            lines.append("‚ö†Ô∏è  Ë≠¶Âëä:")
            for warning in self.warnings:
                lines.append(str(warning))
                lines.append("")
        
        # ÊÉÖÂ†±Ë°®Á§∫Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
        if show_info and self.info:
            lines.append("‚ÑπÔ∏è  ÊÉÖÂ†±:")
            for info in self.info:
                lines.append(str(info))
                lines.append("")
        
        return "\n".join(lines)
    
    def to_file_report(self, output_path: Path) -> None:
        """Ë©≥Á¥∞„É¨„Éù„Éº„Éà„Çí„Éï„Ç°„Ç§„É´„Å´Âá∫Âäõ"""
        report_data = {
            "metadata": {
                "source_file": str(self.source_file) if self.source_file else None,
                "generation_time": self.generation_time.isoformat(),
                "summary": self.get_summary(),
                "counts": {
                    "errors": len(self.errors),
                    "warnings": len(self.warnings),
                    "info": len(self.info)
                }
            },
            "errors": [self._error_to_dict(error) for error in self.errors],
            "warnings": [self._error_to_dict(error) for error in self.warnings],
            "info": [self._error_to_dict(error) for error in self.info]
        }
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, ensure_ascii=False, indent=2)
    
    def _error_to_dict(self, error: DetailedError) -> Dict[str, Any]:
        """DetailedError„ÇíËæûÊõ∏ÂΩ¢Âºè„Å´Â§âÊèõ"""
        return {
            "error_id": error.error_id,
            "severity": error.severity.value,
            "category": error.category.value,
            "title": error.title,
            "message": error.message,
            "file_path": str(error.file_path) if error.file_path else None,
            "location": {
                "line": error.location.line,
                "column": error.location.column,
                "context_start": error.location.context_start,
                "context_end": error.location.context_end
            } if error.location else None,
            "context_lines": error.context_lines,
            "highlighted_line": error.highlighted_line,
            "fix_suggestions": [
                {
                    "description": suggestion.description,
                    "original_text": suggestion.original_text,
                    "suggested_text": suggestion.suggested_text,
                    "action_type": suggestion.action_type,
                    "confidence": suggestion.confidence
                }
                for suggestion in error.fix_suggestions
            ],
            "help_url": error.help_url,
            "learn_more": error.learn_more,
            "timestamp": error.timestamp.isoformat(),
            "additional_info": error.additional_info
        }


class ErrorReportBuilder:
    """„Ç®„É©„Éº„É¨„Éù„Éº„Éà‰ΩúÊàê„Éò„É´„Éë„Éº"""
    
    @staticmethod
    def create_syntax_error(
        title: str,
        message: str,
        file_path: Path,
        line_number: int,
        problem_text: str,
        suggestions: Optional[List[FixSuggestion]] = None
    ) -> DetailedError:
        """Ë®òÊ≥ï„Ç®„É©„Éº„Çí‰ΩúÊàê"""
        return DetailedError(
            error_id=f"syntax_{line_number}_{hash(problem_text) % 10000}",
            severity=ErrorSeverity.ERROR,
            category=ErrorCategory.SYNTAX,
            title=title,
            message=message,
            file_path=file_path,
            location=ErrorLocation(line=line_number),
            highlighted_line=problem_text,
            fix_suggestions=suggestions or [],
            help_url="https://github.com/mo9mo9-uwu-mo9mo9/Kumihan-Formatter/blob/main/SPEC.md"
        )
    
    @staticmethod
    def create_keyword_error(
        invalid_keyword: str,
        file_path: Path,
        line_number: int,
        valid_keywords: List[str]
    ) -> DetailedError:
        """„Ç≠„Éº„ÉØ„Éº„Éâ„Ç®„É©„Éº„Çí‰ΩúÊàê"""
        suggestions = []
        
        # È°û‰ºº„Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆÊèêÊ°à
        similar_keywords = ErrorReportBuilder._find_similar_keywords(invalid_keyword, valid_keywords)
        if similar_keywords:
            for keyword in similar_keywords[:3]:  # ‰∏ä‰Ωç3„Å§„Åæ„Åß
                suggestions.append(FixSuggestion(
                    description=f"'{keyword}' „Çí‰ΩøÁî®„Åô„Çã",
                    original_text=invalid_keyword,
                    suggested_text=keyword,
                    confidence=0.8
                ))
        
        # Ê≠£„Åó„ÅÑË®òÊ≥ï„ÅÆË™¨Êòé
        suggestions.append(FixSuggestion(
            description="‰ΩøÁî®ÂèØËÉΩ„Å™„Ç≠„Éº„ÉØ„Éº„Éâ‰∏ÄË¶ß„ÇíÁ¢∫Ë™ç„Åô„Çã",
            action_type="reference",
            confidence=0.9
        ))
        
        return DetailedError(
            error_id=f"keyword_{line_number}_{hash(invalid_keyword) % 10000}",
            severity=ErrorSeverity.ERROR,
            category=ErrorCategory.KEYWORD,
            title=f"‰∏çÊòé„Å™„Ç≠„Éº„ÉØ„Éº„Éâ: {invalid_keyword}",
            message=f"'{invalid_keyword}' „ÅØÊúâÂäπ„Å™KumihanË®òÊ≥ï„Ç≠„Éº„ÉØ„Éº„Éâ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì",
            file_path=file_path,
            location=ErrorLocation(line=line_number),
            fix_suggestions=suggestions,
            help_url="https://github.com/mo9mo9-uwu-mo9mo9/Kumihan-Formatter/blob/main/SPEC.md",
            additional_info={"invalid_keyword": invalid_keyword, "valid_keywords": valid_keywords}
        )
    
    @staticmethod
    def _find_similar_keywords(target: str, candidates: List[str]) -> List[str]:
        """È°û‰ºº„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÊ§úÁ¥¢Ôºà„Ç∑„É≥„Éó„É´„Å™Á∑®ÈõÜË∑ùÈõ¢„Éô„Éº„ÇπÔºâ"""
        def levenshtein_distance(s1: str, s2: str) -> int:
            if len(s1) < len(s2):
                return levenshtein_distance(s2, s1)
            
            if len(s2) == 0:
                return len(s1)
            
            previous_row = range(len(s2) + 1)
            for i, c1 in enumerate(s1):
                current_row = [i + 1]
                for j, c2 in enumerate(s2):
                    insertions = previous_row[j + 1] + 1
                    deletions = current_row[j] + 1
                    substitutions = previous_row[j] + (c1 != c2)
                    current_row.append(min(insertions, deletions, substitutions))
                previous_row = current_row
            
            return previous_row[-1]
        
        # Á∑®ÈõÜË∑ùÈõ¢„ÅßÈ°û‰ººÂ∫¶„ÇíË®àÁÆó
        similarities = []
        for candidate in candidates:
            distance = levenshtein_distance(target.lower(), candidate.lower())
            if distance <= 2:  # Á∑®ÈõÜË∑ùÈõ¢2‰ª•‰∏ã„ÇíÈ°û‰ºº„Å®„Åø„Å™„Åô
                similarities.append((candidate, distance))
        
        # Á∑®ÈõÜË∑ùÈõ¢„Åß„ÇΩ„Éº„Éà
        similarities.sort(key=lambda x: x[1])
        return [candidate for candidate, _ in similarities]